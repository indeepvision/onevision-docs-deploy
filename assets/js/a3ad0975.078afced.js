"use strict";(self.webpackChunk_indeepvision_onevision_docs=self.webpackChunk_indeepvision_onevision_docs||[]).push([[358],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var a=t(2784);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(t),g=o,d=u["".concat(c,".").concat(g)]||u[g]||m[g]||i;return t?a.createElement(d,r(r({ref:n},p),{},{components:t})):a.createElement(d,r({ref:n},p))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=g;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8556:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=t(7896),o=(t(2784),t(876));const i={sidebar_position:6},r="Function blocks",s={unversionedId:"programming/language_basics/function-blocks",id:"programming/language_basics/function-blocks",title:"Function blocks",description:"In OneVision Scripts, Function Blocks are a powerful feature that allows you to define asynchronous functions and manage their execution in a structured way. A Function Block is similar to a function that can run asynchronously, and it provides a mechanism to handle complex operations efficiently.",source:"@site/docs/programming/2_language_basics/6-function-blocks.md",sourceDirName:"programming/2_language_basics",slug:"/programming/language_basics/function-blocks",permalink:"/onevision/docs/programming/language_basics/function-blocks",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"programmingSidebar",previous:{title:"Functions",permalink:"/onevision/docs/programming/language_basics/functions"},next:{title:"Exception handling",permalink:"/onevision/docs/programming/language_basics/exception-handling"}},c={},l=[{value:"Defining a Function Block",id:"defining-a-function-block",level:3},{value:"Methods in Function Blocks",id:"methods-in-function-blocks",level:3},{value:"Practical Usage",id:"practical-usage",level:3}],p={toc:l},u="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"function-blocks"},"Function blocks"),(0,o.kt)("p",null,"In OneVision Scripts, Function Blocks are a powerful feature that allows you to define asynchronous functions and manage their execution in a structured way. A Function Block is similar to a function that can run asynchronously, and it provides a mechanism to handle complex operations efficiently."),(0,o.kt)("h3",{id:"defining-a-function-block"},"Defining a Function Block"),(0,o.kt)("p",null,"A Function Block in OneVision Scripts is defined within a block named ",(0,o.kt)("inlineCode",{parentName:"p"},"blockName {}"),". This creates a sort of class-like structure with five primary methods: ",(0,o.kt)("inlineCode",{parentName:"p"},"run()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"wait()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"runWait()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"isRunning()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"isDone()"),". Additionally, Function Blocks can define multiple input and output variables to pass parameters and retrieve results."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Syntax:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"block blockName {\n    in var inputName1: type;\n    in var inputName2: type;\n    out var outputName1: type;\n    out var outputName2: type;\n    \n    // Function block code\n}\n")),(0,o.kt)("p",null,"For example: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'block ProcessImage {\n    in var imageData: Ve.Image;\n    in var filterType: string;\n    out var processedData: Ve.Shape2d;\n    out var processingTime: number;\n\n    console.log("Processing image...");\n    let startTime = Date.now();\n    \n    // Simulate some async complex operation\n    waitTime(2000); \n\n    // Finish function block\n    processedData = new Ve.Shape2d(); \n    processingTime = Date.now() - startTime;\n    console.log("Image processed.");\n}\n')),(0,o.kt)("p",null,"Once defined, you can instantiate the block by calling: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"processImage = new ProcessImage(); \n\n")),(0,o.kt)("h3",{id:"methods-in-function-blocks"},"Methods in Function Blocks"),(0,o.kt)("p",null,"Function Blocks in OneVision Scripts come with three built-in methods: ",(0,o.kt)("strong",{parentName:"p"},"run()"),", ",(0,o.kt)("strong",{parentName:"p"},"wait()"),", and ",(0,o.kt)("strong",{parentName:"p"},"runWait()"),". These methods provide different ways to control the execution of the function block, making it easier to handle asynchronous operations."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"run()"),": This method starts the execution of the function block asynchronously. This call won't wait the function block to finish, so it is useful to launch multiple asynchronous tasks at the same time to parallelize their execution."),(0,o.kt)("p",{parentName:"li"},"For example, using the function block defined above: "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'\n// Start processing image asynchronously\nprocessImage.imageData = new Ve.Image(100, 100, Ve.EPixelFormat.BGR8);\nprocessImage.filterType = "blur";\nprocessImage.run();\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"wait()"),": This method waits until the asynchronous function within the block finishes executing. It is useful for synchronizing code execution. For example using the same function block:"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// Wait until the image processing is complete\nprocessImage.imageData = new Ve.Image(100, 100, Ve.EPixelFormat.BGR8);\nprocessImage.filterType = "blur";\nprocessImage.run();\nprocessImage.wait();\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"runWait()"),": This method combines ",(0,o.kt)("inlineCode",{parentName:"p"},"run()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"wait()")," into a single call. It starts the function block execution and waits for it to finish before proceeding. For example, the previous example could be simplified with: "),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'\n// Start processing image and wait until it\'s done\nprocessImage.imageData = new Ve.Image(100, 100, Ve.EPixelFormat.BGR8);\nprocessImage.filterType = "blur";\nprocessImage.runWait();\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"isRunning()"),": This method checks whether the function block is currently executing, returning ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if the block is being executed and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," otherwise. For example, you can use this method in to control wait methods: "),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'\nblock TON{\n in var timeout: number;\n waitTime(timeout); \n}\nvar ton = new TON(); \nton.timeout = 3000; \nton.run(); \nwaitOff(ton.isRunning()); \nconsole.log("Done");\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"isDone()"),": This method checks whether the function block has finished executing, returning ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if if it has and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," otherwise. For example, you can use this method in to control wait methods: "),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'\nblock TON{\n in var timeout: number;\n waitTime(timeout); \n}\nvar ton = new TON(); \nton.timeout = 3000; \nton.run(); \nwaitOn(ton.isDone()); \nconsole.log("Done");\n')))),(0,o.kt)("h3",{id:"practical-usage"},"Practical Usage"),(0,o.kt)("p",null,"Function Blocks are particularly useful in computer vision applications where tasks like image processing, data analysis, or hardware interaction might take considerable time and need to be performed asynchronously to maintain responsiveness in the system."),(0,o.kt)("p",null,"Consider a scenario where you need to process different parts of the image with some complex analysis. Using Function Blocks, you can structure this workflow efficiently and perform the operations in parallel, reducing cycle time of the application:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// Define the function block processing part of an image\nblock ComplexProcessing {\n    in var image: Ve.Image; \n    in var roi: Ve.Rect2d; \n\n    out var result: boolean; \n\n    // Get crop\n    var crop = Ve.cropImage(image, roi);\n\n    // Simulate complex processing\n    waitTime(2000);\n\n    // Return result\n    result = true; \n}\n\nvar proc1 = new ComplexProcessing(); \nvar proc2 = new ComplexProcessing(); \nvar proc3 = new ComplexProcessing(); \n\n// Pass parameters to the function blocks\nvar image = new Ve.Image(1000, 1000, Ve.EPixelFormat.BGR8);\nproc1.image = image;\nproc2.image = image;\nproc3.image = image;\nproc1.roi = new Ve.Rect2d(100,100,100,100);\nproc2.roi = new Ve.Rect2d(300,300,100,100);\nproc3.roi = new Ve.Rect2d(500,500,100,100);\n\n// Run the three function blocks in parallel.\nproc1.run();\nproc2.run();\nproc3.run();\n\n// Wait for the execution of all three blocks to finish.\nproc1.wait();\nproc2.wait();\nproc3.wait();\n\nconsole.log("Complex operations finished");\n\n')))}m.isMDXComponent=!0}}]);